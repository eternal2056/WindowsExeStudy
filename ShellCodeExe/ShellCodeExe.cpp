#include <iostream>
#include <windows.h>
using namespace std;


//------------------------------------------------------------
//-----------       Created with 010 Editor        -----------
//------         www.sweetscape.com/010editor/          ------
//
// File    : D:\Download\Code\WindowsDriver\WindowsExeStudy\x64\Release\ShellCodeCommon.exe
// Address : 1024 (0x400)
// Size    : 1024 (0x400)
//------------------------------------------------------------
unsigned char hexData[1024] = {
	0x40, 0x55, 0x53, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x57, 0x48, 0x8B, 0xEC, 0x48, 0x83, 0xEC,
	0x58, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00, 0x33, 0xFF, 0x48, 0x8B, 0x5D, 0x38,
	0x48, 0x8B, 0x48, 0x60, 0x48, 0x8B, 0x41, 0x18, 0x48, 0x8B, 0x48, 0x10, 0x48, 0x8B, 0x01, 0x48,
	0x8B, 0x08, 0x4C, 0x8B, 0x41, 0x30, 0x49, 0x63, 0x40, 0x3C, 0x42, 0x8B, 0x8C, 0x00, 0x88, 0x00,
	0x00, 0x00, 0x49, 0x03, 0xC8, 0x8B, 0x41, 0x14, 0x44, 0x8B, 0x61, 0x20, 0x44, 0x8B, 0x79, 0x1C,
	0x4D, 0x03, 0xE0, 0x44, 0x8B, 0x69, 0x18, 0x4D, 0x03, 0xF8, 0x8B, 0x49, 0x24, 0x49, 0x03, 0xC8,
	0x48, 0x89, 0x45, 0x40, 0x48, 0x89, 0x4D, 0x48, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x8A, 0x01, 0x00,
	0x00, 0x48, 0x89, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x50, 0x66, 0x90,
	0x41, 0x83, 0x3C, 0xBF, 0x00, 0x0F, 0x84, 0x57, 0x01, 0x00, 0x00, 0x4D, 0x85, 0xED, 0x0F, 0x84,
	0x4E, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF1, 0x4D, 0x8B, 0xF4, 0x49, 0x2B, 0xF4, 0x49, 0x8B, 0xD7,
	0x4D, 0x2B, 0xF7, 0x4D, 0x8B, 0xDD, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x33, 0xC0, 0x49, 0x8D, 0x0C, 0x16, 0x39, 0x04, 0x31, 0x0F, 0x94, 0xC0, 0x48, 0x3B, 0xC7, 0x0F,
	0x85, 0x07, 0x01, 0x00, 0x00, 0x44, 0x8B, 0x09, 0x33, 0xC0, 0x4D, 0x03, 0xC8, 0x41, 0x80, 0x39,
	0x47, 0x0F, 0x94, 0xC0, 0x41, 0x80, 0x79, 0x01, 0x65, 0x8D, 0x48, 0x01, 0x0F, 0x45, 0xC8, 0x41,
	0x80, 0x79, 0x02, 0x74, 0x8D, 0x41, 0x01, 0x0F, 0x45, 0xC1, 0x41, 0x80, 0x79, 0x03, 0x50, 0x8D,
	0x48, 0x01, 0x0F, 0x45, 0xC8, 0x41, 0x80, 0x79, 0x04, 0x72, 0x44, 0x8D, 0x51, 0x01, 0x44, 0x0F,
	0x45, 0xD1, 0x41, 0x83, 0xFA, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79,
	0x05, 0x6F, 0x41, 0x8D, 0x42, 0x01, 0x41, 0x0F, 0x45, 0xC2, 0x83, 0xF8, 0x0E, 0x75, 0x05, 0x8B,
	0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79, 0x06, 0x63, 0x8D, 0x48, 0x01, 0x0F, 0x45, 0xC8, 0x83,
	0xF9, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79, 0x07, 0x41, 0x8D, 0x41,
	0x01, 0x0F, 0x45, 0xC1, 0x83, 0xF8, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80,
	0x79, 0x08, 0x64, 0x8D, 0x48, 0x01, 0x0F, 0x45, 0xC8, 0x83, 0xF9, 0x0E, 0x75, 0x05, 0x8B, 0x1A,
	0x49, 0x03, 0xD8, 0x41, 0x80, 0x79, 0x09, 0x64, 0x8D, 0x41, 0x01, 0x0F, 0x45, 0xC1, 0x83, 0xF8,
	0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79, 0x0A, 0x72, 0x8D, 0x48, 0x01,
	0x0F, 0x45, 0xC8, 0x83, 0xF9, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79,
	0x0B, 0x65, 0x8D, 0x41, 0x01, 0x0F, 0x45, 0xC1, 0x83, 0xF8, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49,
	0x03, 0xD8, 0x41, 0x80, 0x79, 0x0C, 0x73, 0x8D, 0x48, 0x01, 0x0F, 0x45, 0xC8, 0x83, 0xF9, 0x0E,
	0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x41, 0x80, 0x79, 0x0D, 0x73, 0x8D, 0x41, 0x01, 0x0F,
	0x45, 0xC1, 0x83, 0xF8, 0x0E, 0x75, 0x05, 0x8B, 0x1A, 0x49, 0x03, 0xD8, 0x48, 0x83, 0xC2, 0x04,
	0x49, 0x83, 0xEB, 0x01, 0x0F, 0x85, 0xD6, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x45, 0x40, 0x48, 0x8B,
	0x4D, 0x48, 0x48, 0xFF, 0xC7, 0x48, 0x3B, 0xF8, 0x0F, 0x82, 0x92, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B,
	0x74, 0x24, 0x50, 0x48, 0x8B, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x55, 0xE8, 0xC7,
	0x45, 0xE8, 0x4C, 0x6F, 0x61, 0x64, 0x49, 0x8B, 0xC8, 0xC7, 0x45, 0xEC, 0x4C, 0x69, 0x62, 0x72,
	0xC7, 0x45, 0xF0, 0x61, 0x72, 0x79, 0x41, 0xC6, 0x45, 0xF4, 0x00, 0xC7, 0x45, 0xD8, 0x4D, 0x65,
	0x73, 0x73, 0xC7, 0x45, 0xDC, 0x61, 0x67, 0x65, 0x42, 0xC7, 0x45, 0xE0, 0x6F, 0x78, 0x41, 0x00,
	0xC7, 0x45, 0xC8, 0x55, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xCC, 0x33, 0x32, 0x2E, 0x64, 0x66, 0xC7,
	0x45, 0xD0, 0x6C, 0x6C, 0xC6, 0x45, 0xD2, 0x00, 0xC7, 0x45, 0x38, 0x6D, 0x79, 0x4D, 0x61, 0x66,
	0xC7, 0x45, 0x3C, 0x69, 0x6E, 0xC6, 0x45, 0x3E, 0x00, 0xFF, 0xD3, 0x48, 0x8D, 0x4D, 0xC8, 0xFF,
	0xD0, 0x48, 0x8D, 0x55, 0xD8, 0x48, 0x8B, 0xC8, 0xFF, 0xD3, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x45,
	0x38, 0x48, 0x8D, 0x55, 0x38, 0x33, 0xC9, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x58, 0x41, 0x5F, 0x41,
	0x5D, 0x41, 0x5C, 0x5F, 0x5B, 0x5D, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};





// x64 shellcode
//UCHAR shellcode[] = { 0x48,  0x89,  0x5C,  0x24,  0x08,  0x48,  0x89,  0x74,  0x24,  0x10,  0x48,  0x89,  0x7C,  0x24,  0x18,  0x55,  0x41,  0x56,  0x41,  0x57,  0x48,  0x8B,  0xEC,  0x48,  0x81,  0xEC,  0x80,  0x00,  0x00,  0x00,  0xE8,  0x9D,  0x01,  0x00,  0x00,  0x4C,  0x8B,  0xC0,  0x33,  0xDB,  0x8B,  0xFB,  0x48,  0x63,  0x40,  0x3C,  0x42,  0x39,  0x9C,  0x00,  0x8C,  0x00,  0x00,  0x00,  0x0F,  0x84,  0xA7,  0x00,  0x00,  0x00,  0x42,  0x8B,  0x8C,  0x00,  0x88,  0x00,  0x00,  0x00,  0x85,  0xC9,  0x0F,  0x84,  0x97,  0x00,  0x00,  0x00,  0x45,  0x8B,  0x54,  0x08,  0x24,  0x49,  0x8D,  0x04,  0x08,  0x41,  0x8B,  0x4C,  0x08,  0x20,  0x4D,  0x03,  0xD0,  0x44,  0x8B,  0x58,  0x1C,  0x49,  0x03,  0xC8,  0x44,  0x8B,  0x48,  0x18,  0x4D,  0x03,  0xD8,  0x41,  0xFF,  0xC9,  0x8B,  0xD3,  0x8B,  0x01,  0x49,  0x03,  0xC0,  0x80,  0x38,  0x47,  0x75,  0x4E,  0x80,  0x78,  0x01,  0x65,  0x75,  0x48,  0x80,  0x78,  0x02,  0x74,  0x75,  0x42,  0x80,  0x78,  0x03,  0x50,  0x75,  0x3C,  0x80,  0x78,  0x04,  0x72,  0x75,  0x36,  0x80,  0x78,  0x05,  0x6F,  0x75,  0x30,  0x80,  0x78,  0x06,  0x63,  0x75,  0x2A,  0x80,  0x78,  0x07,  0x41,  0x75,  0x24,  0x80,  0x78,  0x08,  0x64,  0x75,  0x1E,  0x80,  0x78,  0x09,  0x64,  0x75,  0x18,  0x80,  0x78,  0x0A,  0x72,  0x75,  0x12,  0x80,  0x78,  0x0B,  0x65,  0x75,  0x0C,  0x80,  0x78,  0x0C,  0x73,  0x75,  0x06,  0x80,  0x78,  0x0D,  0x73,  0x74,  0x0D,  0xFF,  0xC2,  0x48,  0x83,  0xC1,  0x04,  0x41,  0x3B,  0xD1,  0x76,  0x9D,  0xEB,  0x0E,  0x8B,  0xC2,  0x41,  0x0F,  0xB7,  0x0C,  0x42,  0x41,  0x8B,  0x3C,  0x8B,  0x49,  0x03,  0xF8,  0xC7,  0x45,  0xC0,  0x4C,  0x6F,  0x61,  0x64,  0xC7,  0x45,  0xC4,  0x4C,  0x69,  0x62,  0x72,  0xC7,  0x45,  0xC8,  0x61,  0x72,  0x79,  0x57,  0xC6,  0x45,  0xCC,  0x00,  0xE8,  0xBF,  0x00,  0x00,  0x00,  0x48,  0x8B,  0xC8,  0x48,  0x8D,  0x55,  0xC0,  0xFF,  0xD7,  0x48,  0x8D,  0x4D,  0xE8,  0xC7,  0x45,  0xE8,  0x75,  0x00,  0x73,  0x00,  0xC7,  0x45,  0xEC,  0x65,  0x00,  0x72,  0x00,  0xC7,  0x45,  0xF0,  0x33,  0x00,  0x32,  0x00,  0xC7,  0x45,  0xF4,  0x2E,  0x00,  0x64,  0x00,  0xC7,  0x45,  0xF8,  0x6C,  0x00,  0x6C,  0x00,  0x66,  0x89,  0x5D,  0xFC,  0xC7,  0x45,  0xB0,  0x4D,  0x65,  0x73,  0x73,  0xC7,  0x45,  0xB4,  0x61,  0x67,  0x65,  0x42,  0xC7,  0x45,  0xB8,  0x6F,  0x78,  0x57,  0x00,  0xFF,  0xD0,  0x48,  0x8B,  0xC8,  0x48,  0x8D,  0x55,  0xB0,  0xFF,  0xD7,  0x45,  0x33,  0xC9,  0xC7,  0x45,  0xD0,  0x53,  0x00,  0x68,  0x00,  0x4C,  0x8D,  0x45,  0xA0,  0xC7,  0x45,  0xD4,  0x65,  0x00,  0x6C,  0x00,  0x48,  0x8D,  0x55,  0xD0,  0xC7,  0x45,  0xD8,  0x6C,  0x00,  0x63,  0x00,  0x33,  0xC9,  0xC7,  0x45,  0xDC,  0x6F,  0x00,  0x64,  0x00,  0xC7,  0x45,  0xE0,  0x65,  0x00,  0x00,  0x00,  0xC7,  0x45,  0xA0,  0x4C,  0x00,  0x59,  0x00,  0xC7,  0x45,  0xA4,  0x53,  0x00,  0x4D,  0x00,  0x66,  0x89,  0x5D,  0xA8,  0xFF,  0xD0,  0x4C,  0x8D,  0x9C,  0x24,  0x80,  0x00,  0x00,  0x00,  0x33,  0xC0,  0x49,  0x8B,  0x5B,  0x20,  0x49,  0x8B,  0x73,  0x28,  0x49,  0x8B,  0x7B,  0x30,  0x49,  0x8B,  0xE3,  0x41,  0x5F,  0x41,  0x5E,  0x5D,  0xC3,  0xCC,  0xCC,  0xCC,  0xCC,  0xCC,  0xCC,  0xCC,  0xCC,  0x65,  0x48,  0x8B,  0x04,  0x25,  0x60,  0x00,  0x00,  0x00,  0x48,  0x8B,  0x40,  0x18,  0x48,  0x8B,  0x40,  0x30,  0x48,  0x8B,  0x00,  0x48,  0x8B,  0x00,  0x48,  0x8B,  0x40,  0x10,  0xC3,  0x00,  0x00,  0x00,  0x00 };
//int main()
//{
//
//	// some variables statement
//	DWORD targetPid = 0;
//	HANDLE h_target = NULL;
//	LPVOID p_base = NULL;
//	HANDLE h_thread = NULL;
//
//	// get target process handle
//	cout << "input target process id:";
//	cin >> targetPid;
//	h_target = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);
//	if (h_target == NULL) {
//		cout << "OpenProcess failed." << endl;
//		goto main_end;
//	}
//
//	// request memory in target process 
//	p_base = VirtualAllocEx(h_target, NULL, sizeof(hexData), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
//	if (p_base == NULL) {
//		cout << "VirtualAllocEx failed." << endl;
//		goto main_end;
//	}
//
//	// write shellcode in requested memory
//	if (!WriteProcessMemory(h_target, p_base, (LPVOID)hexData, sizeof(hexData), NULL)) {
//		cout << "WriteProcessMemory failed." << endl;
//		goto main_end;
//	}
//
//	// create thread and execute shellcode
//	h_thread = CreateRemoteThread(h_target, 0, 0, (LPTHREAD_START_ROUTINE)p_base, NULL, 0, NULL);
//	if (h_thread == NULL) {
//		cout << "CreateRemoteThread failed." << endl;
//		goto main_end;
//	}
//
//main_end:
//
//	// when MessageBox appears but you don't click the button,
//	// now , call VirtualFreeEx to free memory then click button will lead target procedure to breakdown.
//	/*if (p_base) {
//		VirtualFreeEx(h_target, p_base, 0, MEM_RELEASE);
//	}*/
//	if (h_target)
//		CloseHandle(h_target);
//	if (h_thread)
//		CloseHandle(h_thread);
//	getchar();
//	return 0;
//}
int main()
{
	std::cout << "Hello World!\n";



	LPVOID lpShellcode = VirtualAlloc(NULL, sizeof(hexData), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (lpShellcode == NULL) {
		std::cerr << "VirtualAlloc failed: " << GetLastError() << std::endl;
		return 1;
	}

	SIZE_T lpNumberOfBytesWritten = 0;
	BOOL writeResult = WriteProcessMemory(GetCurrentProcess(), lpShellcode, hexData, sizeof(hexData), &lpNumberOfBytesWritten);
	if (!writeResult || lpNumberOfBytesWritten != sizeof(hexData)) {
		std::cerr << "WriteProcessMemory failed: " << GetLastError() << std::endl;
		VirtualFree(lpShellcode, 0, MEM_RELEASE);
		return 1;
	}

	// 输出写入的内容
	std::cout << "Shellcode written successfully:\n";
	for (int i = 0; i < sizeof(hexData); ++i) {
		printf("%02X ", ((BYTE*)lpShellcode)[i]);
	}
	std::cout << std::endl;

	// 更改内存保护属性
	DWORD oldProtect;
	BOOL protectResult = VirtualProtect(lpShellcode, sizeof(hexData), PAGE_EXECUTE_READ, &oldProtect);
	if (!protectResult) {
		std::cerr << "VirtualProtect failed: " << GetLastError() << std::endl;
		VirtualFree(lpShellcode, 0, MEM_RELEASE);
		return 1;
	}

	HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lpShellcode, NULL, NULL, NULL);
	if (hThread == NULL) {
		std::cerr << "CreateThread failed: " << GetLastError() << std::endl;
		VirtualFree(lpShellcode, 0, MEM_RELEASE);
		return 1;
	}

	// 等待线程结束
	DWORD waitResult = WaitForSingleObject(hThread, INFINITE);
	if (waitResult != WAIT_OBJECT_0) {
		std::cerr << "WaitForSingleObject failed: " << GetLastError() << std::endl;
		CloseHandle(hThread);
		VirtualFree(lpShellcode, 0, MEM_RELEASE);
		return 1;
	}

	// 清理资源

	return 0;




	//HMODULE hModule = LoadLibraryA("kernel32.dll");
	//if (hModule == NULL) {
	//	std::cerr << "Failed to load kernel32.dll\n";
	//	return 1;
	//}

	//// 获取导出表信息
	//IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)hModule;
	//IMAGE_NT_HEADERS* pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)hModule + pDosHeader->e_lfanew);
	//IMAGE_EXPORT_DIRECTORY* pExportDir1 = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)hModule + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	//// 获取导出函数数量
	//DWORD numberOfFunctions = pExportDir1->NumberOfFunctions;
	//DWORD* pNames = reinterpret_cast<DWORD*>(pExportDir1->AddressOfNames + reinterpret_cast<DWORD64>(hModule));

	//// 遍历导出函数名称表并输出每个函数的名称
	//for (DWORD i = 0; i < numberOfFunctions; i++) {
	//	const char* pszFunctionName = reinterpret_cast<const char*>(pNames[i] + reinterpret_cast<DWORD64>(hModule));
	//	std::cout << "Function " << i << ": " << pszFunctionName << std::endl;
	//}

	//// 1. 获取 Kernel32.dll 基地址 或者 ntdll.dll | Kernel32.dll | user32.dll, 有顺序的加载
	//DWORD64 dwKernel32 = 0;
	//// 通过 TEB 获取 PEB
	//_TEB* pTeb = NtCurrentTeb();
	//PDWORD64 pPeb = (PDWORD64) * (PDWORD64)((DWORD64)pTeb + 0x60); // _PEB
	//// 通过 PEB 获取 模块链表 Ldr
	//PDWORD64 pLdr = (PDWORD64) * (PDWORD64)((DWORD64)pPeb + 0x18); // _PEB_LDR_DATA
	//// 通过 Ldr 获取 已加载的模块链表 InLoadOrderModuleList
	//PDWORD64 InLoadOrderModuleList = (PDWORD64)((DWORD64)pLdr + 0x10); // _LIST_ENTRY 里面存的是 _LDR_DATA_TABLE_ENTRY
	///*
	//nt!_LDR_DATA_TABLE_ENTRY
 //  +0x000 InLoadOrderLinks : _LIST_ENTRY				// 模块链表
 //  +0x010 InMemoryOrderLinks : _LIST_ENTRY
 //  +0x020 InInitializationOrderLinks : _LIST_ENTRY
 //  +0x030 DllBase          : Ptr64 Void
 //  +0x038 EntryPoint       : Ptr64 Void
 //  +0x040 SizeOfImage      : Uint4B
 //  +0x048 FullDllName      : _UNICODE_STRING			// exe path
 //  +0x058 BaseDllName      : _UNICODE_STRING
 //  +0x068 FlagGroup        : [4] UChar
 //  +0x068 Flags            : Uint4B
 //  +0x068 PackagedBinary   : Pos 0, 1 Bit
 //  +0x068 MarkedForRemoval : Pos 1, 1 Bit
 //  +0x068 ImageDll         : Pos 2, 1 Bit
 //  +0x068 LoadNotificationsSent : Pos 3, 1 Bit
 //  +0x068 TelemetryEntryProcessed : Pos 4, 1 Bit
 //  +0x068 ProcessStaticImport : Pos 5, 1 Bit
 //  +0x068 InLegacyLists    : Pos 6, 1 Bit
 //  +0x068 InIndexes        : Pos 7, 1 Bit
 //  +0x068 ShimDll          : Pos 8, 1 Bit
 //  +0x068 InExceptionTable : Pos 9, 1 Bit
 //  +0x068 ReservedFlags1   : Pos 10, 2 Bits
 //  +0x068 LoadInProgress   : Pos 12, 1 Bit
 //  +0x068 LoadConfigProcessed : Pos 13, 1 Bit
 //  +0x068 EntryProcessed   : Pos 14, 1 Bit
 //  +0x068 ProtectDelayLoad : Pos 15, 1 Bit
 //  +0x068 ReservedFlags3   : Pos 16, 2 Bits
 //  +0x068 DontCallForThreads : Pos 18, 1 Bit
 //  +0x068 ProcessAttachCalled : Pos 19, 1 Bit
 //  +0x068 ProcessAttachFailed : Pos 20, 1 Bit
 //  +0x068 CorDeferredValidate : Pos 21, 1 Bit
 //  +0x068 CorImage         : Pos 22, 1 Bit
 //  +0x068 DontRelocate     : Pos 23, 1 Bit
 //  +0x068 CorILOnly        : Pos 24, 1 Bit
 //  +0x068 ChpeImage        : Pos 25, 1 Bit
 //  +0x068 ReservedFlags5   : Pos 26, 2 Bits
 //  +0x068 Redirected       : Pos 28, 1 Bit
 //  +0x068 ReservedFlags6   : Pos 29, 2 Bits
 //  +0x068 CompatDatabaseProcessed : Pos 31, 1 Bit
 //  +0x06c ObsoleteLoadCount : Uint2B
 //  +0x06e TlsIndex         : Uint2B
 //  +0x070 HashLinks        : _LIST_ENTRY
 //  +0x080 TimeDateStamp    : Uint4B
 //  +0x088 EntryPointActivationContext : Ptr64 _ACTIVATION_CONTEXT
 //  +0x090 Lock             : Ptr64 Void
 //  +0x098 DdagNode         : Ptr64 _LDR_DDAG_NODE
 //  +0x0a0 NodeModuleLink   : _LIST_ENTRY
 //  +0x0b0 LoadContext      : Ptr64 _LDRP_LOAD_CONTEXT
 //  +0x0b8 ParentDllBase    : Ptr64 Void
 //  +0x0c0 SwitchBackContext : Ptr64 Void
 //  +0x0c8 BaseAddressIndexNode : _RTL_BALANCED_NODE
 //  +0x0e0 MappingInfoIndexNode : _RTL_BALANCED_NODE
 //  +0x0f8 OriginalBase     : Uint8B
 //  +0x100 LoadTime         : _LARGE_INTEGER
 //  +0x108 BaseNameHashValue : Uint4B
 //  +0x10c LoadReason       : _LDR_DLL_LOAD_REASON
 //  +0x110 ImplicitPathOptions : Uint4B
 //  +0x114 ReferenceCount   : Uint4B
 //  +0x118 DependentLoadFlags : Uint4B
 //  +0x11c SigningLevel     : UChar

	//*/
	//PDWORD64 pModExe = (PDWORD64)*InLoadOrderModuleList;
	//PDWORD64 pModNtDll = (PDWORD64)*pModExe;
	//PDWORD64 pModKernel32 = (PDWORD64)*pModNtDll;
	//dwKernel32 = *(pModKernel32 + 6); // DllBase

	//DWORD64 dwBase = dwKernel32;
	//PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)dwKernel32;
	//PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos->e_lfanew + dwKernel32);
	//PIMAGE_DATA_DIRECTORY pExportDir = pNt->OptionalHeader.DataDirectory;
	//// 导出表
	//pExportDir = &pExportDir[IMAGE_DIRECTORY_ENTRY_EXPORT];
	//DWORD64 dwOffset = pExportDir->VirtualAddress;
	//PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(dwOffset + dwBase);
	//// 导出表数据弄出来
	//DWORD64 dwFuncCount = pExport->NumberOfFunctions; // 导出函数的个数
	//DWORD64 dwFuncNameCount = pExport->NumberOfNames;	// 导出函数名字个数
	//// 两个表的地址
	//PDWORD pEnt = (PDWORD)(dwBase + pExport->AddressOfNames); // 这几个都不能用 PDWORD64, 不然就不行, 因为数据存在了DWORD大小,而不是DWORD64
	//PDWORD pEat = (PDWORD)(dwBase + pExport->AddressOfFunctions);
	//// 序号表
	//PDWORD pEit = (PDWORD)(dwBase + pExport->AddressOfNameOrdinals);

	//DWORD64 dwFuncAddress; // GetProcAddress
	//for (size_t i = 0; i < dwFuncCount; i++) {
	//	if (!pEat[i]) {
	//		continue;
	//	}
	//	for (size_t index = 0; index < dwFuncNameCount; index++) {
	//		// 序号表里的值为地址表里的索引
	//		if (!pEit[index] == i) {
	//			DWORD dwNameOffset = pEnt[index]; // 函数名字字符串的偏移量
	//			char* szFuncName = (char*)(dwBase + dwNameOffset);
	//			// 局部变量
	//			char szGetProcAddress[] = {
	//				'G',
	//				'e',
	//				't',
	//				'P',
	//				'r',
	//				'o',
	//				'c',
	//				'A',
	//				'd',
	//				'd',
	//				'r',
	//				'e',
	//				's',
	//				's',
	//			};
	//			int nFlag = 0;
	//			for (size_t j = 0; j < 14; j++) {
	//				if (szFuncName[j] == szGetProcAddress[j]) {
	//					nFlag++;
	//				}
	//				if (nFlag == 14) {
	//					dwFuncAddress = pEat[index] + dwBase;
	//				}
	//			}
	//		}

	//	}
	//}

	//char szLoadLibrary[] = {
	//'L',
	//'o',
	//'a',
	//'d',
	//'L',
	//'i',
	//'b',
	//'r',
	//'a',
	//'r',
	//'y',
	//'A',
	//'\0',
	//};
	//char szGetProcAddress[] = {
	//'G',
	//'e',
	//'t',
	//'P',
	//'r',
	//'o',
	//'c',
	//'A',
	//'d',
	//'d',
	//'r',
	//'e',
	//'s',
	//'s',
	//'\0',
	//};
	//char szMessageBox[] = {
	//'M',
	//'e',
	//'s',
	//'s',
	//'a',
	//'g',
	//'e',
	//'B',
	//'o',
	//'x',
	//'A',
	//'\0',
	//};
	//char szKernel32[] = {
	//'K',
	//'e',
	//'l',
	//'n',
	//'e',
	//'l',
	//'3',
	//'2',
	//'.',
	//'d',
	//'l',
	//'l',
	//'\0',
	//};
	//char szUser32[] = {
	//'U',
	//'s',
	//'e',
	//'r',
	//'3',
	//'2',
	//'.',
	//'d',
	//'l',
	//'l',
	//'\0',
	//};
	//char szMyMain[] = {
	//'m',
	//'y',
	//'M',
	//'a',
	//'i',
	//'n',
	//'\0',
	//};

	//typedef HMODULE(WINAPI* MyLoadLibraryA)(LPCSTR lpLibFileName);
	//typedef FARPROC(WINAPI* MyGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
	//typedef int(WINAPI* MyMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);

	//HMODULE hKner32 = (HMODULE)dwKernel32;
	//MyGetProcAddress pFunGetProcAddress = (MyGetProcAddress)dwFuncAddress;
	//MyLoadLibraryA pFunLoadLibraryAddress;
	//pFunLoadLibraryAddress = (MyLoadLibraryA)pFunGetProcAddress(hKner32, szLoadLibrary);

	//HMODULE hUser32 = pFunLoadLibraryAddress(szUser32);
	//MyMessageBoxA pFuncMegBox;
	//pFuncMegBox = (MyMessageBoxA)pFunGetProcAddress(hUser32, szMessageBox);
	//pFuncMegBox(NULL, szMyMain, szMyMain, MB_OK);
}